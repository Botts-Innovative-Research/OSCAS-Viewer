/* * Copyright (c) 2022.  Botts Innovative Research, Inc. * All Rights Reserved * * opensensorhub/osh-viewer is licensed under the * * Mozilla Public License 2.0 * Permissions of this weak copyleft license are conditioned on making available source code of licensed * files and modifications of those files under the same license (or in certain cases, one of the GNU licenses). * Copyright and license notices must be preserved. Contributors provide an express grant of patent rights. * However, a larger work using the licensed work may be distributed under different terms and without * source code for files added in the larger work. * */import React, {useEffect} from "react";import * as Cesium from 'cesium';import {useAppDispatch, useAppSelector} from "../../state/Hooks";import {selectUseBuildingModels, updateContextMenuState} from "../../state/Slice";let buildingTileset: any = null;let viewer: any = null;const CesiumMap = () => {    const dispatch = useAppDispatch();    let showBuildings = useAppSelector(selectUseBuildingModels);    useEffect(() => {        // Cesium.Ion.defaultAccessToken = null;        // Initialize the Cesium Viewer in the HTML element with the "cesiumContainer" ID.        viewer = new Cesium.Viewer('CesiumMap', {            terrainProvider: Cesium.createWorldTerrain(),            // imageryProvider: new Cesium.IonImageryProvider({assetId: 3954}),            sceneMode: Cesium.SceneMode.SCENE3D,            // infoBox: false,            // geocoder: false,            timeline: false,            animation: false,            homeButton: false,            scene3DOnly: true,            // baseLayerPicker: false,            // sceneModePicker: false,            fullscreenButton: false,            // projectionPicker: false,            // selectionIndicator: false,            // navigationHelpButton: false,            // navigationInstructionsInitiallyVisible: true        });        // Disable autocomplete - uncomment if geocoder is enabled        // viewer.geocoder.viewModel.autoComplete = false;        // Add Cesium OSM Buildings, a global 3D buildings layer.        buildingTileset = viewer.scene.primitives.add(Cesium.createOsmBuildings());        const position = Cesium.Cartesian3.fromDegrees(-86.740290, 34.71963, -.5);        const heading = Cesium.Math.toRadians(90);        const pitch = 0;        const roll = 0;        const hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);        const orientation = Cesium.Transforms.headingPitchRollQuaternion(            position,            hpr        );        // const model = viewer.entities.add({        //     name: ,        //     position: position,        //     orientation: orientation,        //     model: {        //         uri: ,        //         color: Cesium.Color.AQUA,        //         heightReference: HeightReference.RELATIVE_TO_GROUND,        //         scale: 5.5        //         // scale: 10        //     }        // });        // viewer.trackedEntity = model;        // viewer.selectedEntity = model;        // viewer.zoomTo(model);        // Fly the camera to San Francisco at the given longitude, latitude, and height.        viewer.camera.flyTo({            destination: Cesium.Cartesian3.fromDegrees(-74.044500, 40.689249, 8000),            // orientation: {            //     heading: Cesium.Math.toRadians(0.0),            //     pitch: Cesium.Math.toRadians(-15.0),            // }        });        const handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);        handler.setInputAction(function (event: { position: any; }) {            // We use `viewer.scene.pickPosition` here instead of `viewer.camera.pickEllipsoid` so that            // we get the correct point when mousing over terrain.            const earthPosition = viewer.scene.pickPosition(event.position);            // `earthPosition` will be undefined if our mouse is not over the globe.            if (Cesium.defined(earthPosition)) {                dispatch(updateContextMenuState({showMenu: false}));            }        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);        handler.setInputAction(function (movement: { position: any; }) {            dispatch(updateContextMenuState({                showMenu: true, top: movement.position.y, left: movement.position.x            }));        }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);        handler.setInputAction(function (event: { position: any; }) {            // We use `viewer.scene.pickPosition` here instead of `viewer.camera.pickEllipsoid` so that            // we get the correct point when mousing over terrain.            const earthPosition = viewer.scene.pickPosition(event.position);            // `earthPosition` will be undefined if our mouse is not over the globe.            if (Cesium.defined(earthPosition)) {                console.log("Click Pos: " + earthPosition); // position of click            }        }, Cesium.ScreenSpaceEventType.RIGHT_UP);    }, [])    if (viewer != null) {        buildingTileset.show = showBuildings;        viewer.scene.requestRender();    }    return (        <div id={'CesiumMap'} style={{height: '100vh', position: 'relative'}}/>    );}export default CesiumMap;